/**
 * @file lexer.c
 * This file contains the function definitions of the "lexer.h" file.
*/

#include <lexer/lexer.h>
#include <alloc.h>
#include <string.h>
#include <consts.h>
#include <error.h>

/**
 * @def mr_lexer_tokens_free
 * It deallocates the tokens generated by the \a mr_lexer_match function. \n
 * The tokens list doesn't have to be terminated with an EOF token. \n
 * This macro should only be called from the \a mr_lexer function.
*/
#define mr_lexer_tokens_free                       \
    do                                             \
    {                                              \
        while (data.size--)                        \
            mr_free(data.tokens[data.size].value); \
        mr_free(data.tokens);                      \
    } while (0)

/**
 * @def mr_lexer_token_set(typ)
 * Creates a new token with the given type. \n
 * The value of the created token is NULL and it should be one character long. \n
 * This macro should only be called from the \a mr_lexer_match function.
 * @param typ
 * The type of the token that needs to be created.
*/
#define mr_lexer_token_set(typ)  \
    do                           \
    {                            \
        token->type = typ;       \
        token->value = NULL;     \
        token->poss = data->pos; \
        data->pos.idx++;         \
        token->pose = data->pos; \
                                 \
        data->size++;            \
    } while (0)

/**
 * @def mr_lexer_skip_spaces(code, idx)
 * It skips the spaces (' ', '\t', and '\r') from the \a code and advances the <em>idx</em>.
 * @param code
 * The source code.
 * @param idx
 * The index of the current character (the \a idx field of the \a pos structure).
*/
#define mr_lexer_skip_spaces(code, idx)                                \
    while (code[idx] == ' ' || code[idx] == '\t' || code[idx] == '\r') \
        idx++

/**
 * @def mr_lexer_skip_newlines(code, idx, ln)
 * It skips the newlines ('\n') from the \a code and advances the \a idx and the <em>ln</em>.
 * @param code
 * The source code
 * @param idx
 * The index of the current character (the \a idx field of the \a pos structure).
 * @param ln
 * The current line of the \a code (the \a ln field of the \a pos structure).
*/
#define mr_lexer_skip_newlines(code, idx, ln) \
    while (code[idx] == '\n')                 \
    {                                         \
        idx++;                                \
        ln++;                                 \
    }

/**
 * @def mr_lexer_add_newline(prev)
 * Determines that the newline token should be added or not.
 * @param prev
 * The type of the previous token.
 * @return If the newline should be added, It returns \a MR_TRUE and \a MR_FALSE otherwise.
*/
#define mr_lexer_add_newline(prev)                                                        \
    (prev <= MR_TOKEN_STR && prev >= MR_TOKEN_IDENTIFIER) || prev == MR_TOKEN_FSTR_END || \
    prev == MR_TOKEN_TRUE_K || prev == MR_TOKEN_FALSE_K || prev == MR_TOKEN_NONE_K ||     \
    prev == MR_TOKEN_RETURN_K || prev >= MR_TOKEN_OBJECT_T

/**
 * @struct __MR_LEXER_MATCH_T
 * The input of the \a mr_lexer_match function.
 * @var __MR_LEXER_MATCH_T::flag
 * The flag indicates that the matching process succeeded or failed. \n
 * If the process succeeded, the flag will be 0. Otherwise, its value will be the error code.
 * @var __MR_LEXER_MATCH_T::tokens
 * The list of tokens.
 * @var __MR_LEXER_MATCH_T::size
 * The size of the \a tokens list.
 * @var __MR_LEXER_MATCH_T::alloc
 * The allocated size for the \a tokens list. \n
 * It indicates the maximum number of tokens that can be stored in the current \a tokens list.
 * @var __MR_LEXER_MATCH_T::code
 * The source code.
 * @var __MR_LEXER_MATCH_T::pos
 * The position indicating the index of the current character.
*/
struct __MR_LEXER_MATCH_T
{
    mr_byte_t flag;

    mr_token_t *tokens;
    mr_size_t size;
    mr_size_t alloc;

    mr_str_ct code;
    mr_pos_t pos;
};
typedef struct __MR_LEXER_MATCH_T mr_lexer_match_t;

/**
 * @enum __MR_LEXER_MATCH_FLAG_ENUM
 * The list of possible codes returned by the \a mr_lexer_match function.
 * @var __MR_LEXER_MATCH_FLAG_ENUM::MR_LEXER_MATCH_FLAG_OK
 * The matching completed successfully.
 * @var __MR_LEXER_MATCH_FLAG_ENUM::MR_LEXER_MATCH_FLAG_ILLEGAL
 * The function found an illegal character during the matching process.
 * @var __MR_LEXER_MATCH_FLAG_ENUM::MR_LEXER_MATCH_FLAG_MISSING
 * A character is missing from the code.
 * @var __MR_LEXER_MATCH_FLAG_ENUM::MR_LEXER_MATCH_FLAG_MEMORY
 * The process failed due to the memory allocation failure.
*/
enum __MR_LEXER_MATCH_FLAG_ENUM
{
    MR_LEXER_MATCH_FLAG_OK,
    MR_LEXER_MATCH_FLAG_ILLEGAL,
    MR_LEXER_MATCH_FLAG_MISSING,
    MR_LEXER_MATCH_FLAG_MEMORY
};

/**
 * It matches the characters against the lexer patterns and generates tokens one by one.
 * @param data
 * The data structure containing the information about the code.
 * @param end
 * The terminator character. The matching process stops once it gets to this character.
*/
void mr_lexer_match(mr_lexer_match_t *data, mr_chr_t end);

/**
 * It skips the comments (both singleline and multiline ones). \n
 * Singleline comment regex pattern: `\#.*` \n
 * Multiline comment regex pattern: `\#\*(.|\n)*?\*\#`
 * @param data
 * The data structure containing the information about the code.
*/
void mr_lexer_skip_comment(mr_lexer_match_t *data);

/**
 * It generates an identifier, a keyword, or a type bases on the code. \n
 * Identifier regex pattern: `[a-zA-Z_]\w*`
 * @param data
 * The data structure containing the information about the code.
*/
void mr_lexer_generate_identifier(mr_lexer_match_t *data);

/**
 * It generates a number (int, float, or imaginary) based on the code. \n
 * Int regex pattern: `[0-9][0-9_]*` \n
 * Float regex pattern: `([0-9][0-9_]*\.|\.)[0-9_]*` \n
 * Imaginary regex pattern: `([0-9][0-9_]*\.*|\.*)[0-9_]*i`
 * @param data
 * The data structure containing the information about the code.
*/
void mr_lexer_generate_number(mr_lexer_match_t *data);

mr_byte_t mr_lexer(mr_lexer_t *res, mr_str_ct code)
{
    mr_lexer_match_t data;
    data.flag = MR_LEXER_MATCH_FLAG_OK;

    data.tokens = mr_alloc(MR_LEXER_TOKENS_SIZE * sizeof(mr_token_t));
    if (!data.tokens)
        return ERROR_NOT_ENOUGH_MEMORY;

    data.size = 0;
    data.alloc = MR_LEXER_TOKENS_SIZE;

    data.code = code;
    data.pos = (mr_pos_t){0, 1};

    while (1)
    {
        mr_lexer_skip_spaces(code, data.pos.idx);
        if (code[data.pos.idx] == '\n')
        {
            data.pos.idx++;
            data.pos.ln++;
            continue;
        }
        if (code[data.pos.idx] == ';')
        {
            data.pos.idx++;
            continue;
        }

        if (code[data.pos.idx] == '#')
        {
            mr_lexer_skip_comment(&data);
            continue;
        }

        break;
    }

    mr_token_t *block;
    while (code[data.pos.idx] != '\0')
    {
        if (data.size == data.alloc)
        {
            block = mr_realloc(data.tokens,
                (data.alloc += MR_LEXER_TOKENS_SIZE) * sizeof(mr_token_t));
            if (!block)
            {
                mr_lexer_tokens_free;
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            data.tokens = block;
        }

        mr_lexer_match(&data, '\0');
        if (data.flag)
        {
            mr_lexer_tokens_free;

            if (data.flag == MR_LEXER_MATCH_FLAG_MEMORY)
                return ERROR_NOT_ENOUGH_MEMORY;

            res->tokens = NULL;
            res->error = (mr_illegal_chr_t){code[data.pos.idx],
                data.flag == MR_LEXER_MATCH_FLAG_MISSING, data.pos};
            return NO_ERROR;
        }
    }

    if (data.size + 1 != data.alloc)
    {
        block = mr_realloc(data.tokens, (data.size + 1) * sizeof(mr_token_t));
        if (!block)
        {
            mr_lexer_tokens_free;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        data.tokens = block;
    }

    data.tokens[data.size].type = MR_TOKEN_EOF;
    data.tokens[data.size].value = NULL;
    data.tokens[data.size].poss = data.pos;
    data.pos.idx++;
    data.tokens[data.size].pose = data.pos;

    res->tokens = data.tokens;
    return NO_ERROR;
}

void mr_lexer_match(mr_lexer_match_t *data, mr_chr_t end)
{
    // dummy
    if (end != '\0')
        return;

    mr_token_t *token = data->tokens + data->size;
    mr_chr_t chr = data->code[data->pos.idx];

    if (chr == '#')
    {
        mr_lexer_skip_comment(data);
        mr_lexer_skip_spaces(data->code, data->pos.idx);
        return;
    }

    if (chr == '\n')
    {
        mr_token_t *prev = token - 1;
        if (mr_lexer_add_newline(prev->type))
        {
            token->type = MR_TOKEN_NEWLINE;
            token->value = NULL;
            token->poss = data->pos;
            data->pos.idx++;
            data->pos.ln++;
            token->pose = data->pos;

            data->size++;
        }
        else
        {
            data->pos.idx++;
            data->pos.ln++;
        }

        mr_lexer_skip_spaces(data->code, data->pos.idx);
        return;
    }

    if (chr >= '0' && chr <= '9')
    {
        mr_lexer_generate_number(data);
        if (data->flag)
            return;

        mr_lexer_skip_spaces(data->code, data->pos.idx);
        return;
    }

    if ((chr >= 'A' && chr <= 'Z') || (chr >= 'a' && chr <= 'z') || chr == '_')
    {
        mr_lexer_generate_identifier(data);
        if (data->flag)
            return;

        mr_lexer_skip_spaces(data->code, data->pos.idx);
        return;
    }

    switch (chr)
    {
    case ';':
        if ((token - 1)->type == MR_TOKEN_NEWLINE)
        {
            data->pos.idx++;
            break;
        }

        mr_lexer_token_set(MR_TOKEN_NEWLINE);
        break;
    case '~':
        mr_lexer_token_set(MR_TOKEN_B_NOT);
        break;
    case '(':
        mr_lexer_token_set(MR_TOKEN_L_PAREN);
        break;
    case ')':
        mr_lexer_token_set(MR_TOKEN_L_PAREN);
        break;
    case '[':
        mr_lexer_token_set(MR_TOKEN_L_SQUARE);
        break;
    case ']':
        mr_lexer_token_set(MR_TOKEN_R_SQUARE);
        break;
    case '{':
        mr_lexer_token_set(MR_TOKEN_L_CURLY);
        break;
    case '}':
        mr_lexer_token_set(MR_TOKEN_R_CURLY);
        break;
    case ',':
        mr_lexer_token_set(MR_TOKEN_COMMA);
        break;
    case ':':
        mr_lexer_token_set(MR_TOKEN_COLON);
        break;
    case '?':
        mr_lexer_token_set(MR_TOKEN_QUESTION);
        break;
    case '$':
        mr_lexer_token_set(MR_TOKEN_DOLLAR);
        break;
    default:
        data->flag = MR_LEXER_MATCH_FLAG_ILLEGAL;
        return;
    }

    mr_lexer_skip_spaces(data->code, data->pos.idx);
}

void mr_lexer_skip_comment(mr_lexer_match_t *data)
{
    if (data->code[++data->pos.idx] != '*')
    {
        while (data->code[data->pos.idx] != '\0' && data->code[data->pos.idx] != '\n')
            data->pos.idx++;

        return;
    }

    data->pos.idx++;
    while (data->code[data->pos.idx] != '\0')
    {
        if (data->code[data->pos.idx] == '*')
        {
            data->pos.idx++;
            if (data->code[data->pos.idx] == '#')
            {
                data->pos.idx++;
                return;
            }
        }

        if (data->code[data->pos.idx] == '\n')
            data->pos.ln++;
        data->pos.idx++;
    }
}

void mr_lexer_generate_identifier(mr_lexer_match_t *data)
{
    mr_token_t *token = data->tokens + data->size++;

    token->value = mr_alloc(MR_LEXER_IDENTIFIER_SIZE * sizeof(mr_chr_t));
    if (!token->value)
    {
        data->flag = MR_LEXER_MATCH_FLAG_MEMORY;
        return;
    }

    token->size = 0;
    token->poss = data->pos;

    mr_size_t alloc = MR_LEXER_IDENTIFIER_SIZE;

    mr_str_t block;
    mr_chr_t chr = data->code[data->pos.idx];
    do
    {
        if (token->size == alloc)
        {
            block = mr_realloc(token->value, (alloc += MR_LEXER_IDENTIFIER_SIZE) * sizeof(mr_chr_t));
            if (!block)
            {
                mr_free(token->value);

                data->flag = MR_LEXER_MATCH_FLAG_MEMORY;
                return;
            }

            token->value = block;
        }

        token->value[token->size++] = chr;
        chr = data->code[++data->pos.idx];
    } while ((chr >= 'A' && chr <= 'Z') || (chr >= 'a' && chr <= 'z') ||
        (chr >= '0' && chr <= '9') || chr == '_');

    token->pose = data->pos;

    mr_size_t i;
    if (token->size <= MR_TOKEN_KEYWORD_MAXSIZE)
    {
        for (i = 0; i < MR_TOKEN_KEYWORD_COUNT; i++)
            if (token->size == mr_token_keyword_size[i] &&
                !memcmp(token->value, mr_token_keyword[i], token->size))
            {
                mr_free(token->value);

                token->type = i + MR_TOKEN_KEYWORD_PAD;
                token->value = NULL;
                return;
            }

        if (token->size <= MR_TOKEN_TYPE_MAXSIZE)
            for (i = 0; i < MR_TOKEN_TYPE_COUNT; i++)
                if (token->size == mr_token_type_size[i] &&
                    !memcmp(token->value, mr_token_type[i], token->size))
                {
                    mr_free(token->value);

                    token->type = i + MR_TOKEN_TYPE_PAD;
                    token->value = NULL;
                    return;
                }
    }

    if (token->size != alloc)
    {
        block = mr_realloc(token->value, token->size);
        if (!block)
        {
            mr_free(token->value);

            data->flag = MR_LEXER_MATCH_FLAG_MEMORY;
            return;
        }

        token->value = block;
    }

    token->type = MR_TOKEN_IDENTIFIER;
}

void mr_lexer_generate_number(mr_lexer_match_t *data)
{
    mr_token_t *token = data->tokens + data->size++;

    token->value = mr_alloc(MR_LEXER_NUMBER_SIZE * sizeof(mr_chr_t));
    if (!token->value)
    {
        data->flag = MR_LEXER_MATCH_FLAG_MEMORY;
        return;
    }

    token->type = MR_TOKEN_INT;
    token->size = 0;
    token->poss = data->pos;

    mr_bool_t is_float = MR_FALSE;
    mr_size_t alloc = MR_LEXER_NUMBER_SIZE;

    mr_str_t block;
    mr_chr_t chr;
    do
    {
        chr = data->code[data->pos.idx];
        if (chr == '_')
        {
            data->pos.idx++;
            continue;
        }

        if (chr == '.')
        {
            if (is_float)
                break;

            token->type = MR_TOKEN_FLOAT;
            is_float = MR_TRUE;
        }
        else if (chr <= '0' || chr >= '9')
            break;

        if (token->size == alloc)
        {
            block = mr_realloc(token->value, (alloc += MR_LEXER_NUMBER_SIZE) * sizeof(mr_chr_t));
            if (!block)
            {
                mr_free(token->value);

                data->flag = MR_LEXER_MATCH_FLAG_MEMORY;
                return;
            }

            token->value = block;
        }

        token->value[token->size++] = chr;
        data->pos.idx++;
    } while (1);

    if (token->size + 1 != alloc)
    {
        block = mr_realloc(token->value, token->size + 1);
        if (!block)
        {
            mr_free(token->value);

            data->flag = MR_LEXER_MATCH_FLAG_MEMORY;
            return;
        }

        token->value = block;
    }

    token->value[token->size] = '\0';

    if (data->code[data->pos.idx] == 'i')
    {
        token->type = MR_TOKEN_IMAGINARY;
        data->pos.idx++;
    }

    token->pose = data->pos;
    return;
}
